#[derive(Debug, PartialEq, Clone, Copy)]
pub enum OpCode {
    Add = 1,
    Subtract = 2,
    Multiply = 3,
    Divide = 4,
    Modulus = 5,
    Min = 6,
    Max = 7,
    Pow = 8,
    Sqrt = 9,
    Abs = 10,
    Sign = 11,
    Exp = 12,
    Floor = 13,
    Log = 14,
    Ln = 15,
    Round = 16,
    Sin = 17,
    Cos = 18,
    Tan = 19,
    Asin = 20,
    Acos = 21,
    Atan = 22,
    Atan2 = 23,
    Mad = 25,
    IfElse = 26,
    Clamp = 27,
    Cbrt = 28,
    Deg = 29,
    Rad = 30,
    Ceil = 31,
    Rand = 39,
    RandSeed = 40,
    NoiseFrom = 41,
    RandInRange = 42,
    SquareSum = 43,
    Step = 44,
    Square = 45,
    Dup = 46,
    Hypot = 47,
    Swap = 48,
    Lerp = 49,
    SmoothStep = 50,
    Log2 = 51,
    Inv = 52,
    Fract = 53,
    PingPong = 54,
    Nop = 55,
    StoreR0 = 56,
    StoreR1 = 57,
    StoreR2 = 58,
    StoreR3 = 59,
    LoadR0 = 60,
    LoadR1 = 61,
    LoadR2 = 62,
    LoadR3 = 63,
    Var1 = 70,
    Var2 = 71,
    Var3 = 72,
    ChangeSign = 73,
    Cubic = 74,
}

impl OpCode {
    pub fn from_u32(val: u32) -> Option<Self> {
        match val {
            1 => Some(OpCode::Add),
            2 => Some(OpCode::Subtract),
            3 => Some(OpCode::Multiply),
            4 => Some(OpCode::Divide),
            5 => Some(OpCode::Modulus),
            6 => Some(OpCode::Min),
            7 => Some(OpCode::Max),
            8 => Some(OpCode::Pow),
            9 => Some(OpCode::Sqrt),
            10 => Some(OpCode::Abs),
            11 => Some(OpCode::Sign),
            12 => Some(OpCode::Exp),
            13 => Some(OpCode::Floor),
            14 => Some(OpCode::Log),
            15 => Some(OpCode::Ln),
            16 => Some(OpCode::Round),
            17 => Some(OpCode::Sin),
            18 => Some(OpCode::Cos),
            19 => Some(OpCode::Tan),
            20 => Some(OpCode::Asin),
            21 => Some(OpCode::Acos),
            22 => Some(OpCode::Atan),
            23 => Some(OpCode::Atan2),
            25 => Some(OpCode::Mad),
            26 => Some(OpCode::IfElse),
            27 => Some(OpCode::Clamp),
            28 => Some(OpCode::Cbrt),
            29 => Some(OpCode::Deg),
            30 => Some(OpCode::Rad),
            31 => Some(OpCode::Ceil),
            39 => Some(OpCode::Rand),
            40 => Some(OpCode::RandSeed),
            41 => Some(OpCode::NoiseFrom),
            42 => Some(OpCode::RandInRange),
            43 => Some(OpCode::SquareSum),
            44 => Some(OpCode::Step),
            45 => Some(OpCode::Square),
            46 => Some(OpCode::Dup),
            47 => Some(OpCode::Hypot),
            48 => Some(OpCode::Swap),
            49 => Some(OpCode::Lerp),
            50 => Some(OpCode::SmoothStep),
            51 => Some(OpCode::Log2),
            52 => Some(OpCode::Inv),
            53 => Some(OpCode::Fract),
            54 => Some(OpCode::PingPong),
            55 => Some(OpCode::Nop),
            56 => Some(OpCode::StoreR0),
            57 => Some(OpCode::StoreR1),
            58 => Some(OpCode::StoreR2),
            59 => Some(OpCode::StoreR3),
            60 => Some(OpCode::LoadR0),
            61 => Some(OpCode::LoadR1),
            62 => Some(OpCode::LoadR2),
            63 => Some(OpCode::LoadR3),
            70 => Some(OpCode::Var1),
            71 => Some(OpCode::Var2),
            72 => Some(OpCode::Var3),
            73 => Some(OpCode::ChangeSign),
            74 => Some(OpCode::Cubic),
            _ => None,
        }
    }

    pub fn to_math_name(&self) -> &'static str {
        match self {
            OpCode::Add => "+",
            OpCode::Subtract => "-",
            OpCode::Multiply => "*",
            OpCode::Divide => "/",
            OpCode::Modulus => "%",
            OpCode::Min => "min",
            OpCode::Max => "max",
            OpCode::Pow => "pow",
            OpCode::Sqrt => "sqrt",
            OpCode::Abs => "abs",
            OpCode::Sign => "sign",
            OpCode::Exp => "exp",
            OpCode::Floor => "floor",
            OpCode::Log => "log",
            OpCode::Ln => "ln",
            OpCode::Round => "round",
            OpCode::Sin => "sin",
            OpCode::Cos => "cos",
            OpCode::Tan => "tan",
            OpCode::Asin => "asin",
            OpCode::Acos => "acos",
            OpCode::Atan => "atan",
            OpCode::Atan2 => "atan2",
            OpCode::Mad => "mad",
            OpCode::IfElse => "ifElse",
            OpCode::Clamp => "clamp",
            OpCode::Cbrt => "cbrt",
            OpCode::Deg => "deg",
            OpCode::Rad => "rad",
            OpCode::Ceil => "ceil",
            OpCode::Rand => "RAND",
            OpCode::RandSeed => "RAND_SEED",
            OpCode::NoiseFrom => "noise_from",
            OpCode::RandInRange => "rand_in_range",
            OpCode::SquareSum => "square_sum",
            OpCode::Step => "step",
            OpCode::Square => "square",
            OpCode::Dup => "dup",
            OpCode::Hypot => "hypot",
            OpCode::Swap => "swap",
            OpCode::Lerp => "lerp",
            OpCode::SmoothStep => "smooth_step",
            OpCode::Log2 => "log2",
            OpCode::Inv => "inv",
            OpCode::Fract => "fract",
            OpCode::PingPong => "ping_pong",
            OpCode::Nop => "nop",
            OpCode::StoreR0 => "store0",
            OpCode::StoreR1 => "store1",
            OpCode::StoreR2 => "store2",
            OpCode::StoreR3 => "store3",
            OpCode::LoadR0 => "load0",
            OpCode::LoadR1 => "load1",
            OpCode::LoadR2 => "load2",
            OpCode::LoadR3 => "load3",
            OpCode::Var1 => "a[0]",
            OpCode::Var2 => "a[1]",
            OpCode::Var3 => "a[2]",
            OpCode::ChangeSign => "change_sign",
            OpCode::Cubic => "cubic",
        }
    }
}
